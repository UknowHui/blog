---
title: 栈和堆
slug: stack
date: 2018-05-31
categories:
- iOS
- home
tags:
- iOS
---

栈和堆
<!--more-->

栈区(stack)：栈是用于存放本地变量，内部临时变量以及有关上下文的内存区域，程序在调用函数时，操作系统会自动通过压栈和弹栈完成保存函数现场等操作，不需要程序员手动干预。

栈是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的。能从栈获得的空间较小，如果申请的空间超过栈的剩余空间时，例如递归深度过深。
栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。

由编译器自动分配释放，存放函数的参数值，局部变量等值。其操作方式类似于数据结构中的栈。

堆区(heap)：堆是用于存放除了栈里东西之外所有其他东西的内存区域，当使用malloc和free时就是在操作堆中的内存，对于堆来说，释放工作由程序员控制，容易产生memory leak。
堆是向高地址扩展的数据结构，是不连续的内存区域，这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址，堆的大小受限于计算机系统中有效的虚拟内存，由此可见，堆获得的空间比较灵活，也比较大。

对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低，对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，永远都不可能有一个内存块从栈中间弹出.

堆都是动态分配的，没有静态分配的堆。栈有两种分配方式，静态分配和动态分配，静态分配是编译器完成的，比如局部变量的分配，动态分配是由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。

计算机底层并没有对堆的支持，堆则是c/c++函数库提供的，同时由于上面提到的碎片问题，都会导致堆的效率比栈要低。一般由程序员分配释放，若程序员不释放，则可能会引起内存泄漏，堆和数据结构中的堆不一样，其类是与链表。

- .bss：即Block Started by Symbol，为初始化的全局变量和静态变量。
- .data：初始化了的全局变量和静态变量。
- .rodata:程序中的常量
- .text：程序代码

{{< codeblock >}}
int a = 0; 全局初始化区
char *p1; 全局未初始化区
main() {
 int b;
 char s[] = “abc";
 char *p2;
 char *p3 = “123456”; 123456在常量区，p3在栈上
 static int c = 0; 全局静态初始化区
 p1 = (char *)malloc(10); 堆区
 p2 = (char *)malloc(20); 堆区
 strcopy(p1, "123456"); 123456放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方。
{{< /codeblock >}}

使用栈就像是我们去饭馆里吃饭，只管点菜(发出申请)、吃(使用)，吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。
使用堆就像是自己动手做喜欢吃的菜，比较麻烦，但是比较符合自己的口味，而且自由度大。